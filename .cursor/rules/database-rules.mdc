---
description: Guidelines for writing Postgres SQL
globs: **/*
alwaysApply: false
---
# TypeORM Style Guide
## General
- Use consistent naming conventions and follow TypeScript/JavaScript best practices.
- Organize your entity classes logically and maintain clear separation of concerns.
- Use decorators appropriately to define relationships and constraints.
- Leverage TypeORM's query builder for complex queries instead of writing raw SQL.
- Include descriptive comments for complex logic or business rules.

## Naming Conventions
- Use PascalCase for entity class names (e.g., `User`, `BookCategory`).
- Use camelCase for properties within entity classes.
- Follow singular naming for entity classes (representing a single record).
- Use descriptive names that clearly indicate the purpose of the entity or property.

## Entities
- Create a separate file for each entity in an `entities` directory.
- Always extend the `BaseEntity` class when possible for additional functionality.
- Define a primary ID column with `@PrimaryGeneratedColumn()` unless otherwise specified.
- Place entities in a domain-specific module structure.
- Add a class-level JSDoc comment to describe what the entity represents.

## Properties and Columns
- Use camelCase for property names.
- For foreign key relationships, use the singular entity name with 'Id' suffix in the database (e.g., `userId`).
- Use appropriate TypeORM decorators to specify column types and constraints.
- Include nullable constraints explicitly with `@Column({ nullable: true/false })`.
- Document complex properties with JSDoc comments.

#### Examples:
```typescript
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, JoinColumn, BaseEntity } from 'typeorm';
import { Author } from './Author';

/**
 * Represents a book in the library system.
 */
@Entity({ name: 'books' })
export class Book extends BaseEntity {
  @PrimaryGeneratedColumn('increment')
  id: number;

  @Column({ type: 'text', nullable: false })
  title: string;

  @Column({ name: 'author_id' })
  authorId: number;

  @ManyToOne(() => Author)
  @JoinColumn({ name: 'author_id' })
  author: Author;
}
```

## Queries
- Use TypeORM's query builder for complex queries instead of raw SQL.
- Chain methods in a readable format with appropriate indentation.
- For simpler queries, keep the chain on fewer lines. As complexity increases, add line breaks.

Smaller queries:
```typescript
const employees = await Employee.find({
  where: { endDate: IsNull() }
});

await Employee.update({ id: 1001 }, { endDate: new Date('2023-12-31') });
```

Larger queries:
```typescript
const employees = await getRepository(Employee)
  .createQueryBuilder('employee')
  .select(['employee.firstName', 'employee.lastName'])
  .where('employee.startDate BETWEEN :startDate AND :endDate', {
    startDate: '2021-01-01',
    endDate: '2021-12-31'
  })
  .andWhere('employee.status = :status', { status: 'employed' })
  .getMany();
```

### Joins and Relations
- Use descriptive aliases in query builders.
- Prefer explicit join conditions over magic relations for complex queries.
- Use the appropriate join type (innerJoin, leftJoin, etc.) based on requirements.

```typescript
const employeesWithDepartments = await getRepository(Employee)
  .createQueryBuilder('employee')
  .select(['employee.employeeName', 'department.departmentName'])
  .innerJoin('employee.department', 'department')
  .where('employee.startDate > :date', { date: '2022-01-01' })
  .getMany();
```

## Aliases
- Use meaningful aliases in query builders that reflect the entity or relationship.
- Keep aliases concise but descriptive.

```typescript
const employeeCount = await getRepository(Employee)
  .createQueryBuilder('employee')
  .select('COUNT(*)', 'totalEmployees')
  .where('employee.endDate IS NULL')
  .getRawOne();
```

## Complex Queries and Subqueries
- Break down complex queries into smaller, reusable functions.
- Use TypeORM's subquery capabilities for complex data requirements.
- Add comments to explain complex logic or business rules.

```typescript
async function getDepartmentEmployeeCounts() {
  // First get employees with their departments
  const departmentEmployeesQuery = getRepository(Employee)
    .createQueryBuilder('employee')
    .select([
      'employee.departmentId',
      'department.departmentName'
    ])
    .innerJoin('employee.department', 'department');

  // Then count employees per department
  const employeeCounts = await getRepository(Department)
    .createQueryBuilder('department')
    .select([
      'department.departmentName',
      'COUNT(employee.id) AS numEmployees'
    ])
    .leftJoin('department.employees', 'employee')
    .groupBy('department.departmentName')
    .orderBy('department.departmentName', 'ASC')
    .getRawMany();

  return employeeCounts;
}
```

## Migrations
- Name migration files with a timestamp prefix and descriptive name.
- Create separate migration files for each logical change to the database.
- Include both `up` and `down` methods to ensure reversibility.
- Comment complex migration logic for future reference.

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class CreateBooksTable1633036800000 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      CREATE TABLE books (
        id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        title TEXT NOT NULL,
        author_id BIGINT REFERENCES authors (id)
      );
      COMMENT ON TABLE books IS 'A list of all the books in the library.';
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE books`);
  }
}
```

## Repository Pattern
- Create a repository class for each entity to encapsulate data access logic.
- Use custom repositories for complex data operations.
- Keep business logic out of repositories when possible.

```typescript
@EntityRepository(Book)
export class BookRepository extends Repository<Book> {
  /**
   * Find books by a specific author
   */
  async findByAuthor(authorId: number): Promise<Book[]> {
    return this.find({
      where: { authorId },
      relations: ['author']
    });
  }
}
```